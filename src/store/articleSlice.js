import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import reddit from "../common/utils/reddit";

const initialState = {
  article: {
    id: "",
    title: "",
    author: "",
    num_comments: 0,
    created_utc: new Date().getTime() / 1000,
    selftext_html: "",
    url: "",
    post_hint: "",
    ups: 0,
    likes: null,
    is_reddit_media_domain: false,
    is_self: false,
    is_video: false,
  },
  status: "loading",
  errorMsg: "",
};

function getErrorMsg(errorCode) {
  switch (errorCode) {
    case 404:
      return "No article found.";
    default:
      return "Something went wrong...";
  }
}

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchArticle = createAsyncThunk(
  "article/fetchArticle",
  async ({ articleId, subreddit }) => {
    if (articleId) {
      const response = await reddit
        .comments(articleId, subreddit)
        .limit(1)
        .fetch();
      // The value we return becomes the `fulfilled` action payload
      return response[0] ? response[0].data : response;
    }
    return null;
  }
);

export const articleSlice = createSlice({
  name: "article",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    updateSelectedArticle: (state, action) => {
      if (action.payload) {
        state.article = action.payload;
      }
    },
    updateSelectedArticleVote: (state, action) => {
      if (
        action.payload &&
        action.payload.voteType !== undefined &&
        action.payload.id === state.article.id
      ) {
        state.article.ups = action.payload.voteCount;
        state.article.likes = action.payload.voteType;
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchArticle.pending, (state) => {
        state.status = "loading";
        state.errorMsg = "";
      })
      .addCase(fetchArticle.fulfilled, (state, action) => {
        state.status = "loaded";
        if (action.payload && action.payload.children) {
          let article = action.payload.children[0]
            ? action.payload.children[0].data
            : {};
          state.article = article;
        } else if (action.payload && action.payload.error) {
          state.errorMsg = getErrorMsg(action.payload.error);
        }
      })
      .addCase(fetchArticle.rejected, (state, action) => {
        state.status = "error";
        state.errorMsg = getErrorMsg(404);
      });
  },
});

export const { updateSelectedArticle, updateSelectedArticleVote } =
  articleSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.subreddit.value)`
export const selectArticle = (state) => state.selectedArticle.article;
export const selectErrorMsg = (state) => state.selectedArticle.errorMsg;

export default articleSlice.reducer;
